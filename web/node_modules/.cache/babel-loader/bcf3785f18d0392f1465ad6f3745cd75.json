{"ast":null,"code":"import _slicedToArray from \"/home/g/Desktop/hacks/nerr/web/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { useEffect, useRef, useReducer, useCallback, useDebugValue, useMemo } from 'react';\n/* istanbul ignore file */\n\n/**\n * Universal global scope object. In the browser this is `self`, in Node.js and React Native it's `global`.\n * This file is excluded from coverage reporting because these globals are environment-specific so we can't test them all.\n */\n\nconst globalScope = (() => {\n  if (typeof self === \"object\" && self.self === self) return self;\n  if (typeof global === \"object\" && global.global === global) return global;\n  if (typeof global === \"object\" && global.GLOBAL === global) return global;\n  return {}; // fallback that relies on imported modules to be singletons\n})();\n/**\n * Globally available object used to connect the DevTools to all React Async instances.\n */\n\n\nglobalScope.__REACT_ASYNC__ = globalScope.__REACT_ASYNC__ || {};\nlet PropTypes;\n\ntry {\n  PropTypes = require(\"prop-types\");\n} catch (e) {}\n\nconst childrenFn = PropTypes && PropTypes.oneOfType([PropTypes.node, PropTypes.func]);\nconst stateObject = PropTypes && PropTypes.shape({\n  initialValue: PropTypes.any,\n  data: PropTypes.any,\n  error: PropTypes.instanceOf(Error),\n  value: PropTypes.any,\n  startedAt: PropTypes.instanceOf(Date),\n  finishedAt: PropTypes.instanceOf(Date),\n  status: PropTypes.oneOf([\"initial\", \"pending\", \"fulfilled\", \"rejected\"]),\n  isInitial: PropTypes.bool,\n  isPending: PropTypes.bool,\n  isLoading: PropTypes.bool,\n  isFulfilled: PropTypes.bool,\n  isResolved: PropTypes.bool,\n  isRejected: PropTypes.bool,\n  isSettled: PropTypes.bool,\n  counter: PropTypes.number,\n  promise: PropTypes.instanceOf(Promise),\n  run: PropTypes.func,\n  reload: PropTypes.func,\n  cancel: PropTypes.func,\n  setData: PropTypes.func,\n  setError: PropTypes.func\n});\nvar propTypes = PropTypes && {\n  Async: {\n    children: childrenFn,\n    promise: PropTypes.instanceOf(Promise),\n    promiseFn: PropTypes.func,\n    deferFn: PropTypes.func,\n    watch: PropTypes.any,\n    watchFn: PropTypes.func,\n    initialValue: PropTypes.any,\n    onResolve: PropTypes.func,\n    onReject: PropTypes.func,\n    reducer: PropTypes.func,\n    dispatcher: PropTypes.func,\n    debugLabel: PropTypes.string,\n    suspense: PropTypes.bool\n  },\n  Initial: {\n    children: childrenFn.isRequired,\n    state: stateObject.isRequired,\n    persist: PropTypes.bool\n  },\n  Pending: {\n    children: childrenFn.isRequired,\n    state: stateObject.isRequired,\n    initial: PropTypes.bool\n  },\n  Fulfilled: {\n    children: childrenFn.isRequired,\n    state: stateObject.isRequired,\n    persist: PropTypes.bool\n  },\n  Rejected: {\n    children: childrenFn.isRequired,\n    state: stateObject.isRequired,\n    persist: PropTypes.bool\n  },\n  Settled: {\n    children: childrenFn.isRequired,\n    state: stateObject.isRequired,\n    persist: PropTypes.bool\n  }\n};\n\nconst nullify = children => children === undefined ? null : children;\n\nconst renderFn = (children, ...args) => nullify(typeof children === \"function\" ? children(...args) : children);\n/**\n * Renders only when no promise has started or completed yet.\n *\n * @prop {Function|Node} children Function (passing state) or React node\n * @prop {Object} state React Async state object\n * @prop {boolean} persist Show until we have data, even while pending (loading) or when an error occurred\n */\n\n\nconst IfInitial = ({\n  children,\n  persist,\n  state = {}\n}) => state.isInitial || persist && !state.data ? renderFn(children, state) : null;\n/**\n * Renders only while pending (promise is loading).\n *\n * @prop {Function|Node} children Function (passing state) or React node\n * @prop {Object} state React Async state object\n * @prop {boolean} initial Show only on initial load (data is undefined)\n */\n\n\nconst IfPending = ({\n  children,\n  initial,\n  state = {}\n}) => state.isPending && (!initial || !state.value) ? renderFn(children, state) : null;\n/**\n * Renders only when promise is resolved.\n *\n * @prop {Function|Node} children Function (passing data and state) or React node\n * @prop {Object} state React Async state object\n * @prop {boolean} persist Show old data while pending (promise is loading)\n */\n\n\nconst IfFulfilled = ({\n  children,\n  persist,\n  state = {}\n}) => state.isFulfilled || persist && state.data ? renderFn(children, state.data, state) : null;\n/**\n * Renders only when promise is rejected.\n *\n * @prop {Function|Node} children Function (passing error and state) or React node\n * @prop {Object} state React Async state object\n * @prop {boolean} persist Show old error while pending (promise is loading)\n */\n\n\nconst IfRejected = ({\n  children,\n  persist,\n  state = {}\n}) => state.isRejected || persist && state.error ? renderFn(children, state.error, state) : null;\n/**\n * Renders only when promise is fulfilled or rejected.\n *\n * @prop {Function|Node} children Function (passing state) or React node\n * @prop {Object} state React Async state object\n * @prop {boolean} persist Show old data or error while pending (promise is loading)\n */\n\n\nconst IfSettled = ({\n  children,\n  persist,\n  state = {}\n}) => state.isSettled || persist && state.value ? renderFn(children, state) : null;\n\nif (propTypes) {\n  IfInitial.propTypes = propTypes.Initial;\n  IfPending.propTypes = propTypes.Pending;\n  IfFulfilled.propTypes = propTypes.Fulfilled;\n  IfRejected.propTypes = propTypes.Rejected;\n  IfSettled.propTypes = propTypes.Settled;\n}\n\nconst statusTypes = {\n  initial: \"initial\",\n  pending: \"pending\",\n  fulfilled: \"fulfilled\",\n  rejected: \"rejected\"\n};\n\nconst getInitialStatus = (value, promise) => {\n  if (value instanceof Error) return statusTypes.rejected;\n  if (value !== undefined) return statusTypes.fulfilled;\n  if (promise) return statusTypes.pending;\n  return statusTypes.initial;\n};\n\nconst getIdleStatus = value => {\n  if (value instanceof Error) return statusTypes.rejected;\n  if (value !== undefined) return statusTypes.fulfilled;\n  return statusTypes.initial;\n};\n\nconst getStatusProps = status => ({\n  status,\n  isInitial: status === statusTypes.initial,\n  isPending: status === statusTypes.pending,\n  isLoading: status === statusTypes.pending,\n  // alias\n  isFulfilled: status === statusTypes.fulfilled,\n  isResolved: status === statusTypes.fulfilled,\n  // alias\n  isRejected: status === statusTypes.rejected,\n  isSettled: status === statusTypes.fulfilled || status === statusTypes.rejected\n});\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass NeverSettle extends Promise {\n  constructor() {\n    super(() => {}, () => {});\n    /* istanbul ignore next */\n\n    if (Object.setPrototypeOf) {\n      // Not available in IE 10, but can be polyfilled\n      Object.setPrototypeOf(this, NeverSettle.prototype);\n    }\n  }\n\n  finally() {\n    return this;\n  }\n\n  catch() {\n    return this;\n  }\n\n  then() {\n    return this;\n  }\n\n}\n\nconst neverSettle = new NeverSettle();\nconst actionTypes = {\n  start: \"start\",\n  cancel: \"cancel\",\n  fulfill: \"fulfill\",\n  reject: \"reject\"\n};\n\nconst init = ({\n  initialValue,\n  promise,\n  promiseFn\n}) => _objectSpread({\n  initialValue,\n  data: initialValue instanceof Error ? undefined : initialValue,\n  error: initialValue instanceof Error ? initialValue : undefined,\n  value: initialValue,\n  startedAt: promise || promiseFn ? new Date() : undefined,\n  finishedAt: initialValue ? new Date() : undefined\n}, getStatusProps(getInitialStatus(initialValue, promise || promiseFn)), {\n  counter: 0,\n  promise: neverSettle\n});\n\nconst reducer = (state, {\n  type,\n  payload,\n  meta\n}) => {\n  switch (type) {\n    case actionTypes.start:\n      return _objectSpread({}, state, {\n        startedAt: new Date(),\n        finishedAt: undefined\n      }, getStatusProps(statusTypes.pending), {\n        counter: meta.counter,\n        promise: meta.promise\n      });\n\n    case actionTypes.cancel:\n      return _objectSpread({}, state, {\n        startedAt: undefined,\n        finishedAt: undefined\n      }, getStatusProps(getIdleStatus(state.error || state.data)), {\n        counter: meta.counter,\n        promise: meta.promise\n      });\n\n    case actionTypes.fulfill:\n      return _objectSpread({}, state, {\n        data: payload,\n        value: payload,\n        error: undefined,\n        finishedAt: new Date()\n      }, getStatusProps(statusTypes.fulfilled), {\n        promise: meta.promise\n      });\n\n    case actionTypes.reject:\n      return _objectSpread({}, state, {\n        error: payload,\n        value: payload,\n        finishedAt: new Date()\n      }, getStatusProps(statusTypes.rejected), {\n        promise: meta.promise\n      });\n\n    default:\n      return state;\n  }\n};\n\nconst dispatchMiddleware = dispatch => (action, ...args) => {\n  dispatch(action, ...args);\n\n  if (action.type === actionTypes.start && typeof action.payload === \"function\") {\n    action.payload();\n  }\n};\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$1(source, true).forEach(function (key) {\n        _defineProperty$1(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty$1(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * createInstance allows you to create instances of Async that are bound to a specific promise.\n * A unique instance also uses its own React context for better nesting capability.\n */\n\n\nconst createInstance = (defaultOptions = {}, displayName = \"Async\") => {\n  const _React$createContext = React.createContext(),\n        Consumer = _React$createContext.Consumer,\n        Provider = _React$createContext.Provider;\n\n  class Async extends React.Component {\n    constructor(props) {\n      super(props);\n      this.start = this.start.bind(this);\n      this.load = this.load.bind(this);\n      this.run = this.run.bind(this);\n      this.cancel = this.cancel.bind(this);\n      this.onResolve = this.onResolve.bind(this);\n      this.onReject = this.onReject.bind(this);\n      this.setData = this.setData.bind(this);\n      this.setError = this.setError.bind(this);\n      const promise = props.promise;\n      const promiseFn = props.promiseFn || defaultOptions.promiseFn;\n      const initialValue = props.initialValue || defaultOptions.initialValue;\n      this.mounted = false;\n      this.counter = 0;\n      this.args = [];\n      this.promise = neverSettle;\n      this.abortController = {\n        abort: () => {}\n      };\n      this.state = _objectSpread$1({}, init({\n        initialValue,\n        promise,\n        promiseFn\n      }), {\n        cancel: this.cancel,\n        run: this.run,\n        reload: () => {\n          this.load();\n          this.run(...this.args);\n        },\n        setData: this.setData,\n        setError: this.setError\n      });\n      this.debugLabel = props.debugLabel || defaultOptions.debugLabel;\n      const devToolsDispatcher = globalScope.__REACT_ASYNC__.devToolsDispatcher;\n\n      const _reducer = props.reducer || defaultOptions.reducer;\n\n      const _dispatcher = props.dispatcher || defaultOptions.dispatcher || devToolsDispatcher;\n\n      const reducer$1 = _reducer ? (state, action) => _reducer(state, action, reducer) : reducer;\n      const dispatch = dispatchMiddleware((action, callback) => {\n        this.setState(state => reducer$1(state, action), callback);\n      });\n      this.dispatch = _dispatcher ? action => _dispatcher(action, dispatch, props) : dispatch;\n    }\n\n    componentDidMount() {\n      this.mounted = true;\n\n      if (this.props.promise || !this.state.initialValue) {\n        this.load();\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      const _this$props = this.props,\n            watch = _this$props.watch,\n            _this$props$watchFn = _this$props.watchFn,\n            watchFn = _this$props$watchFn === void 0 ? defaultOptions.watchFn : _this$props$watchFn,\n            promise = _this$props.promise,\n            promiseFn = _this$props.promiseFn;\n\n      if (watch !== prevProps.watch) {\n        if (this.counter) this.cancel();\n        return this.load();\n      }\n\n      if (watchFn && watchFn(_objectSpread$1({}, defaultOptions, {}, this.props), _objectSpread$1({}, defaultOptions, {}, prevProps))) {\n        if (this.counter) this.cancel();\n        return this.load();\n      }\n\n      if (promise !== prevProps.promise) {\n        if (this.counter) this.cancel();\n        if (promise) return this.load();\n      }\n\n      if (promiseFn !== prevProps.promiseFn) {\n        if (this.counter) this.cancel();\n        if (promiseFn) return this.load();\n      }\n    }\n\n    componentWillUnmount() {\n      this.cancel();\n      this.mounted = false;\n    }\n\n    getMeta(meta) {\n      return _objectSpread$1({\n        counter: this.counter,\n        promise: this.promise,\n        debugLabel: this.debugLabel\n      }, meta);\n    }\n\n    start(promiseFn) {\n      if (\"AbortController\" in globalScope) {\n        this.abortController.abort();\n        this.abortController = new globalScope.AbortController();\n      }\n\n      this.counter++;\n      return this.promise = new Promise((resolve, reject) => {\n        if (!this.mounted) return;\n\n        const executor = () => promiseFn().then(resolve, reject);\n\n        this.dispatch({\n          type: actionTypes.start,\n          payload: executor,\n          meta: this.getMeta()\n        });\n      });\n    }\n\n    load() {\n      const promise = this.props.promise;\n      const promiseFn = this.props.promiseFn || defaultOptions.promiseFn;\n\n      if (promise) {\n        this.start(() => promise).then(this.onResolve(this.counter)).catch(this.onReject(this.counter));\n      } else if (promiseFn) {\n        const props = _objectSpread$1({}, defaultOptions, {}, this.props);\n\n        this.start(() => promiseFn(props, this.abortController)).then(this.onResolve(this.counter)).catch(this.onReject(this.counter));\n      }\n    }\n\n    run(...args) {\n      const deferFn = this.props.deferFn || defaultOptions.deferFn;\n\n      if (deferFn) {\n        this.args = args;\n\n        const props = _objectSpread$1({}, defaultOptions, {}, this.props);\n\n        return this.start(() => deferFn(args, props, this.abortController)).then(this.onResolve(this.counter), this.onReject(this.counter));\n      }\n    }\n\n    cancel() {\n      const onCancel = this.props.onCancel || defaultOptions.onCancel;\n      onCancel && onCancel();\n      this.counter++;\n      this.abortController.abort();\n      this.mounted && this.dispatch({\n        type: actionTypes.cancel,\n        meta: this.getMeta()\n      });\n    }\n\n    onResolve(counter) {\n      return data => {\n        if (this.counter === counter) {\n          const onResolve = this.props.onResolve || defaultOptions.onResolve;\n          this.setData(data, () => onResolve && onResolve(data));\n        }\n\n        return data;\n      };\n    }\n\n    onReject(counter) {\n      return error => {\n        if (this.counter === counter) {\n          const onReject = this.props.onReject || defaultOptions.onReject;\n          this.setError(error, () => onReject && onReject(error));\n        }\n\n        return error;\n      };\n    }\n\n    setData(data, callback) {\n      this.mounted && this.dispatch({\n        type: actionTypes.fulfill,\n        payload: data,\n        meta: this.getMeta()\n      }, callback);\n      return data;\n    }\n\n    setError(error, callback) {\n      this.mounted && this.dispatch({\n        type: actionTypes.reject,\n        payload: error,\n        error: true,\n        meta: this.getMeta()\n      }, callback);\n      return error;\n    }\n\n    render() {\n      const _this$props2 = this.props,\n            children = _this$props2.children,\n            suspense = _this$props2.suspense;\n\n      if (suspense && this.state.isPending && this.promise !== neverSettle) {\n        // Rely on Suspense to handle the loading state\n        throw this.promise;\n      }\n\n      if (typeof children === \"function\") {\n        return React.createElement(Provider, {\n          value: this.state\n        }, children(this.state));\n      }\n\n      if (children !== undefined && children !== null) {\n        return React.createElement(Provider, {\n          value: this.state\n        }, children);\n      }\n\n      return null;\n    }\n\n  }\n\n  if (propTypes) Async.propTypes = propTypes.Async;\n\n  const AsyncInitial = props => React.createElement(Consumer, null, st => React.createElement(IfInitial, _extends({}, props, {\n    state: st\n  })));\n\n  const AsyncPending = props => React.createElement(Consumer, null, st => React.createElement(IfPending, _extends({}, props, {\n    state: st\n  })));\n\n  const AsyncFulfilled = props => React.createElement(Consumer, null, st => React.createElement(IfFulfilled, _extends({}, props, {\n    state: st\n  })));\n\n  const AsyncRejected = props => React.createElement(Consumer, null, st => React.createElement(IfRejected, _extends({}, props, {\n    state: st\n  })));\n\n  const AsyncSettled = props => React.createElement(Consumer, null, st => React.createElement(IfSettled, _extends({}, props, {\n    state: st\n  })));\n\n  AsyncInitial.displayName = \"\".concat(displayName, \".Initial\");\n  AsyncPending.displayName = \"\".concat(displayName, \".Pending\");\n  AsyncFulfilled.displayName = \"\".concat(displayName, \".Fulfilled\");\n  AsyncRejected.displayName = \"\".concat(displayName, \".Rejected\");\n  AsyncSettled.displayName = \"\".concat(displayName, \".Settled\");\n  Async.displayName = displayName;\n  Async.Initial = AsyncInitial;\n  Async.Pending = AsyncPending;\n  Async.Loading = AsyncPending; // alias\n\n  Async.Fulfilled = AsyncFulfilled;\n  Async.Resolved = AsyncFulfilled; // alias\n\n  Async.Rejected = AsyncRejected;\n  Async.Settled = AsyncSettled;\n  return Async;\n};\n\nvar Async = createInstance();\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$2(source, true).forEach(function (key) {\n        _defineProperty$2(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty$2(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst noop = () => {};\n\nconst useAsync = (arg1, arg2) => {\n  const options = typeof arg1 === \"function\" ? _objectSpread$2({}, arg2, {\n    promiseFn: arg1\n  }) : arg1;\n  const counter = useRef(0);\n  const isMounted = useRef(true);\n  const lastArgs = useRef(undefined);\n  const lastOptions = useRef(undefined);\n  const lastPromise = useRef(neverSettle);\n  const abortController = useRef({\n    abort: noop\n  });\n  const devToolsDispatcher = globalScope.__REACT_ASYNC__.devToolsDispatcher;\n  const reducer$1 = options.reducer,\n        _options$dispatcher = options.dispatcher,\n        dispatcher = _options$dispatcher === void 0 ? devToolsDispatcher : _options$dispatcher;\n\n  const _useReducer = useReducer(reducer$1 ? (state, action) => reducer$1(state, action, reducer) : reducer, options, init),\n        _useReducer2 = _slicedToArray(_useReducer, 2),\n        state = _useReducer2[0],\n        _dispatch = _useReducer2[1];\n\n  const dispatch = useCallback(dispatcher ? action => dispatcher(action, dispatchMiddleware(_dispatch), lastOptions.current) : dispatchMiddleware(_dispatch), [dispatcher]);\n  const debugLabel = options.debugLabel;\n  const getMeta = useCallback(meta => _objectSpread$2({\n    counter: counter.current,\n    promise: lastPromise.current,\n    debugLabel\n  }, meta), [debugLabel]);\n  const setData = useCallback((data, callback = noop) => {\n    if (isMounted.current) {\n      dispatch({\n        type: actionTypes.fulfill,\n        payload: data,\n        meta: getMeta()\n      });\n      callback();\n    }\n\n    return data;\n  }, [dispatch, getMeta]);\n  const setError = useCallback((error, callback = noop) => {\n    if (isMounted.current) {\n      dispatch({\n        type: actionTypes.reject,\n        payload: error,\n        error: true,\n        meta: getMeta()\n      });\n      callback();\n    }\n\n    return error;\n  }, [dispatch, getMeta]);\n  const onResolve = options.onResolve,\n        onReject = options.onReject;\n  const handleResolve = useCallback(count => data => count === counter.current && setData(data, () => onResolve && onResolve(data)), [setData, onResolve]);\n  const handleReject = useCallback(count => err => count === counter.current && setError(err, () => onReject && onReject(err)), [setError, onReject]);\n  const start = useCallback(promiseFn => {\n    if (\"AbortController\" in globalScope) {\n      abortController.current.abort();\n      abortController.current = new globalScope.AbortController();\n    }\n\n    counter.current++;\n    return lastPromise.current = new Promise((resolve, reject) => {\n      if (!isMounted.current) return;\n\n      const executor = () => promiseFn().then(resolve, reject);\n\n      dispatch({\n        type: actionTypes.start,\n        payload: executor,\n        meta: getMeta()\n      });\n    });\n  }, [dispatch, getMeta]);\n  const promise = options.promise,\n        promiseFn = options.promiseFn,\n        initialValue = options.initialValue;\n  const load = useCallback(() => {\n    const isPreInitialized = initialValue && counter.current === 0;\n\n    if (promise) {\n      start(() => promise).then(handleResolve(counter.current)).catch(handleReject(counter.current));\n    } else if (promiseFn && !isPreInitialized) {\n      start(() => promiseFn(lastOptions.current, abortController.current)).then(handleResolve(counter.current)).catch(handleReject(counter.current));\n    }\n  }, [start, promise, promiseFn, initialValue, handleResolve, handleReject]);\n  const deferFn = options.deferFn;\n  const run = useCallback((...args) => {\n    if (deferFn) {\n      lastArgs.current = args;\n      start(() => deferFn(args, lastOptions.current, abortController.current)).then(handleResolve(counter.current)).catch(handleReject(counter.current));\n    }\n  }, [start, deferFn, handleResolve, handleReject]);\n  const reload = useCallback(() => {\n    lastArgs.current ? run(...lastArgs.current) : load();\n  }, [run, load]);\n  const onCancel = options.onCancel;\n  const cancel = useCallback(() => {\n    onCancel && onCancel();\n    counter.current++;\n    abortController.current.abort();\n    isMounted.current && dispatch({\n      type: actionTypes.cancel,\n      meta: getMeta()\n    });\n  }, [onCancel, dispatch, getMeta]);\n  /* These effects should only be triggered on changes to specific props */\n\n  /* eslint-disable react-hooks/exhaustive-deps */\n\n  const watch = options.watch,\n        watchFn = options.watchFn;\n  useEffect(() => {\n    if (watchFn && lastOptions.current && watchFn(options, lastOptions.current)) load();\n  });\n  useEffect(() => {\n    lastOptions.current = options;\n  }, [options]);\n  useEffect(() => {\n    if (counter.current) cancel();\n    if (promise || promiseFn) load();\n  }, [promise, promiseFn, watch]);\n  useEffect(() => () => isMounted.current = false, []);\n  useEffect(() => () => cancel(), []);\n  /* eslint-enable react-hooks/exhaustive-deps */\n\n  useDebugValue(state, ({\n    status\n  }) => \"[\".concat(counter.current, \"] \").concat(status));\n\n  if (options.suspense && state.isPending && lastPromise.current !== neverSettle) {\n    // Rely on Suspense to handle the loading state\n    throw lastPromise.current;\n  }\n\n  return useMemo(() => _objectSpread$2({}, state, {\n    run,\n    reload,\n    cancel,\n    setData,\n    setError\n  }), [state, run, reload, cancel, setData, setError]);\n};\n\nclass FetchError extends Error {\n  constructor(response) {\n    super(\"\".concat(response.status, \" \").concat(response.statusText));\n    /* istanbul ignore next */\n\n    if (Object.setPrototypeOf) {\n      // Not available in IE 10, but can be polyfilled\n      Object.setPrototypeOf(this, FetchError.prototype);\n    }\n\n    this.response = response;\n  }\n\n}\n\nconst parseResponse = (accept, json) => res => {\n  if (!res.ok) return Promise.reject(new FetchError(res));\n  if (typeof json === \"boolean\") return json ? res.json() : res;\n  return accept === \"application/json\" ? res.json() : res;\n};\n\nconst useAsyncFetch = (resource, init, _ref = {}) => {\n  let defer = _ref.defer,\n      json = _ref.json,\n      options = _objectWithoutProperties(_ref, [\"defer\", \"json\"]);\n\n  const method = resource.method || init && init.method;\n  const headers = resource.headers || init && init.headers || {};\n  const accept = headers[\"Accept\"] || headers[\"accept\"] || headers.get && headers.get(\"accept\");\n\n  const doFetch = (resource, init) => globalScope.fetch(resource, init).then(parseResponse(accept, json));\n\n  const isDefer = typeof defer === \"boolean\" ? defer : [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"].indexOf(method) !== -1;\n  const fn = isDefer ? \"deferFn\" : \"promiseFn\";\n  const identity = JSON.stringify({\n    resource,\n    init,\n    isDefer\n  });\n  const state = useAsync(_objectSpread$2({}, options, {\n    [fn]: useCallback((arg1, arg2, arg3) => {\n      const _ref2 = isDefer ? [arg1[0], arg3.signal] : [undefined, arg2.signal],\n            _ref3 = _slicedToArray(_ref2, 2),\n            override = _ref3[0],\n            signal = _ref3[1];\n\n      const isEvent = typeof override === \"object\" && \"preventDefault\" in override;\n\n      if (!override || isEvent) {\n        return doFetch(resource, _objectSpread$2({\n          signal\n        }, init));\n      }\n\n      if (typeof override === \"function\") {\n        const _override = override(_objectSpread$2({\n          resource,\n          signal\n        }, init)),\n              runResource = _override.resource,\n              runInit = _objectWithoutProperties(_override, [\"resource\"]);\n\n        return doFetch(runResource || resource, _objectSpread$2({\n          signal\n        }, runInit));\n      }\n\n      const runResource = override.resource,\n            runInit = _objectWithoutProperties(override, [\"resource\"]);\n\n      return doFetch(runResource || resource, _objectSpread$2({\n        signal\n      }, init, {}, runInit));\n    }, [identity] // eslint-disable-line react-hooks/exhaustive-deps\n    )\n  }));\n  useDebugValue(state, ({\n    counter,\n    status\n  }) => \"[\".concat(counter, \"] \").concat(status));\n  return state;\n};\n/* istanbul ignore next */\n\n\nconst unsupported = () => {\n  throw new Error(\"useAsync requires React v16.8 or up. Upgrade your React version or use the <Async> component instead.\");\n};\n\nvar useAsync$1 = useEffect ? useAsync : unsupported;\nconst useFetch = useEffect ? useAsyncFetch : unsupported;\nexport default Async;\nexport { Async, FetchError, IfFulfilled, IfInitial, IfPending, IfRejected, IfSettled, actionTypes, createInstance, dispatchMiddleware, globalScope, init, neverSettle, reducer, statusTypes, useAsync$1 as useAsync, useFetch };","map":null,"metadata":{},"sourceType":"module"}